# Mysql 联合索引问题
## 场景一 数据表verify_all_column有三个字段（a,b,c）,并建立联合索引 index_abc (a,b,c),此时以下语句,会发现使用了索引index_abc
> mysql> explain select * from verify_all_column where b>1 and  c>3;
+----+-------------+-------------------+------------+-------+---------------+-----------+---------+------+------+----------+--------------------------+
| id | select_type | table             | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------------------+------------+-------+---------------+-----------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | verify_all_column | NULL       | index | index_abc     | index_abc | 15      | NULL |    6 |    16.67 | Using where; Using index |
+----+-------------+-------------------+------------+-------+---------------+-----------+---------+------+------+----------+--------------------------+

如果使用联合索引的最左匹配来解释，肯定是解释不同的，因为where条件中的c是不满足的最左匹配的，那为什么mysql又确实走了这个联合索引呢？
其原因在于此时不能使用联合索引的原理来解释这个问题，而应该用索引覆盖的原理来解释，
> 一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’
对于上述场景mysql会认为通过联合索引就能查到所有的内容，不需要再回表，这样的效率更高
## 场景二 数据表verify_index有三个字段（a,b,c,d）,并建立联合索引 index_abc (a,b,c)
此时查询 exlain select a,b,c from verify_index where c=3,会发现就完全符合最左匹配的原则了
